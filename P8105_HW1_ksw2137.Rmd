---
title: "Homework 1 - P8105/Data Science I"
author: "Kevin S.W."
date: "9/12/2019"
output: github_document
---

```{r setup, include = FALSE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(echo = TRUE, eval = TRUE)
library(tidyverse)  ## loads tidyverse package; if not installed, use install(tidyverse) prior

```

# **Introduction**
This is an R-Markdown document for P8105 Homework 1. Tidyverse was loaded through a chunk with `include = FALSE, message = FALSE, warning = FALSE`. 

# Problem 1
## *Problem 1.a*
Data frame containing the variables as commented. 

```{r Problem_1a}

## Seed used for reproducibility.
set.seed(2)


## Creates a data-frame that is composed of vectors below
prob1_df <- tibble(
  sample = rnorm(8),                              ## Vector for random normal-distributed sample of size 8
  vec_logic = sample > 0,                         ## Logical vector that evaluates if elements in sample > 0
  vec_char = c("GitHub", "is", "super",           ## Character vector with 8 variables ("length == 8")
               "interesting", "and", "awesome", 
               "I", "can't even..."),
  vec_fac = factor(c("corn", "not corn", "corn",  ## Factor vector size 8 with 3 levels: "corn", 
              "maybe corn", "corn", "maybe corn", ## "maybe corn", "not corn"
              "corn", "not corn"))
)


## pull() function pulls the vectors inside prob1_df and turns it into usable variables outside the df. This is 
## inconvenient at this point but makes downstream access to these vectors easier. 
## Using prob1_df$vector was considered bad syntax and was not utilized
var_sample <- pull(prob1_df, sample)
var_vec_logic <- pull(prob1_df, vec_logic)
var_vec_char <- pull(prob1_df, vec_char)
var_vec_fac <- pull(prob1_df, vec_fac)


## Takes the mean for each vectors
mean(var_sample)
mean(var_vec_logic)
mean(var_vec_char)
mean(var_vec_fac)

```

Taking the mean of sample seems to work as expected as it is a continuous variable. Logical vector surprisingly spits out a mean of `r mean(var_vec_logic)`. Looking into `prob1_df` seems to indicate that `FALSE` = 0 while `TRUE` = 1, which leads to `r length(which(var_vec_logic == TRUE))`/`r length(var_vec_logic)` TRUE, hence the calculated mean.

Mean for `var_vec_char` & `var_vec_fac` however, does not work. This is likely because characters are not read as "numbers" and therefore cannot be mathematically manipulated. 

## *Problem 1.b*
Applying the as.numeric() function to logical, character, and factor variables:

```{r Problem_1b, eval = FALSE}

as.numeric(var_vec_logic)
as.numeric(var_vec_char)
as.numeric(var_vec_fac)

```

The command outputs a numeric value that represents each element in the vectors. While the logical vector shows 0/1, character vector shows NA indicating that it doesn't have a numeric representation. Factor vectors however, has the value 1-3; this does not explain why factor vectors cannot output a mean. 

In the following code chunk, we explore this peculiarity:

```{r Problem_1c}

as.numeric(var_vec_logic) * var_sample      ## Convert logical vector to numeric then multiplied with sample
as.factor(var_vec_logic) * var_sample       ## Convert logical vector to factor then multiplied with sample
as.numeric(as.factor(var_vec_logic)) * var_sample ## Convert logical vector to factor then numeric then multiplied                                                       with sample

```

With this exploration, we now can guesstimate that `factor()` stores the elements inside as characters categorized based on the "levels". Only when we convert these elements into numeric using `as.numeric` to get their numerical representation of the "levels" can we then operate on the factor as "numbers". We also notice that when we do this, `FALSE` is assigned 1 instead of 0 as in logical vectors, which indicates that a factor's lowest "numeric" is 1. 

# Problem 2
## *Problem 2.a*
Data frame for problem 2. 

```{r Problem_2a}

prob2_df <- tibble(
  x = rnorm(500),                ## Vector 1 of random normal distribution sample; size 500 
  y = rnorm(500),                ## Vector 2 of random normal distribution sample; size 500 
  xy_logic = (x + y) > 1,        ## Logical vector that evaluates the argument x + y > 1
  xy_num = as.numeric(xy_logic), ## Vector that coerces xy_logic to be numeric vector
  xy_fac = as.factor(xy_logic)   ## Vector that coerces xy_logic to a factor vector
)


## pulls variable from prob2_df out of the df so it's usable outside
var_x <- pull(prob2_df, x)
var_xy_logic <- pull(prob2_df, xy_logic)

```

The `prob2_df` dataframe is a dataset of `r nrow(prob2_df) * ncol(prob2_df)` points in a grid of `r nrow(prob2_df)` rows X `r ncol(prob2_df)` columns. Columns contain values for `x`, `y`, `xy_logic`, `xy_num`, and `xy_fac`. 

The `x` column has a mean of `r mean(var_x)`, median of `r median(var_x)`, and standard deviation of `r sd(var_x)`.

The proportion of `TRUE` cases where `(x + y) > 1` is `r length(which(var_xy_logic == TRUE))`/`r length(var_xy_logic)`, which is `r (length(which(var_xy_logic == TRUE)) / length(var_xy_logic)) * 100`%.

## *Problem 2.b*
Make a scatterplot of y vs x; color points using the logical variable (adding color = ... inside of aes in your ggplot code should help). Make a second and third scatterplot that color points using the numeric and factor variables, respectively, and comment on the color scales.

```{r}

ggplot(data = prob2_df) + 
  geom_point(aes(x = y, y = x), col = ifelse(var_xy_logic == TRUE, "red", "blue"))

```

Export your first scatterplot to your project directory using ggsave