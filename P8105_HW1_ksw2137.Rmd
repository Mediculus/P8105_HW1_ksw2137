---
title: "Homework 1 - P8105/Data Science I"
author: "Kevin S.W."
date: "9/12/2019"
output: html_document
---

```{r setup, include = FALSE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(echo = TRUE, eval = TRUE)
library(tidyverse)  ## loads tidyverse package; if not installed, use install(tidyverse) prior

```

# **Introduction**
This is an R-Markdown document for P8105 Homework 1. Tidyverse was loaded through a chunk with `include = FALSE, message = FALSE, warning = FALSE`. 

# Problem 1
## *Problem 1.a*
Making a data frame with:

* random sample; size 8, type = standard Normal distribution
* logical vector indicating whether elements of the sample are greater than 0
* Character vector; length = 8
* factor vector; length = 8, with 3 different factor “levels”
* Taking the mean of each variable in your dataframe. What works and what doesn’t?

```{r Problem_1a}

## Seed used for reproducibility; remove for "true" function.
set.seed(2)


## Creates a data-frame that is composed of vectors below
prob1_df <- tibble(
  sample = rnorm(8),                              ## Vector for random normal-distributed sample of size 8
  vec_logic = sample > 0,                         ## Logical vector that evaluates if elements in sample > 0
  vec_char = c("GitHub", "is", "super",           ## Character vector with 8 variables ("length == 8")
               "interesting", "and", "awesome", 
               "I", "can't even..."),
  vec_fac = factor(c("corn", "not corn", "corn",  ## Factor vector size 8 with 3 levels: "corn", 
              "maybe corn", "corn", "maybe corn", ## "maybe corn", "not corn"
              "corn", "not corn"))
)


## pull() function pulls the vectors inside prob1_df and turns it into usable variables outside the df. This is 
## inconvenient at this point but makes downstream access to these vectors easier. 
## Using prob1_df$vector was considered bad syntax and was not utilized
var_sample <- pull(prob1_df, sample)
var_vec_logic <- pull(prob1_df, vec_logic)
var_vec_char <- pull(prob1_df, vec_char)
var_vec_fac <- pull(prob1_df, vec_fac)


## Takes the mean for each vectors
mean(var_sample)
mean(var_vec_logic)
mean(var_vec_char)
mean(var_vec_fac)

```

Taking the mean of sample seems to work as expected as it is a continuous variable. Logical vector surprisingly spits out a mean of `r mean(var_vec_logic)`. Looking into `prob1_df` seems to indicate that `FALSE` = 0 while `TRUE` = 1, which leads to `r length(which(var_vec_logic == TRUE))`/`r length(var_vec_logic)` TRUE, thus the calculated mean.

Mean for `var_vec_char` & `var_vec_fac` however, does not work. This is likely because characters are not read as "numbers" and therefore cannot be mathematically manipulated. 

## *Problem 1.b*
Write a code chunk that applies the as.numeric function to the logical, character, and factor variables (please show this chunk but not the output). What happens, and why? Does this help explain what happens when you try to take the mean?

```{r Problem_1b, eval = FALSE}

as.numeric(var_vec_logic)
as.numeric(var_vec_char)
as.numeric(var_vec_fac)

```

The command attempts to output a numeric value that represents each element in the vectors. While the logical vector shows 0/1, character vector shows NA indicating that it doesn't have a numeric representation. Factor vectors however, has the value 1-3; this does not explain why factor vectors cannot obtain the mean. 

In the following code chunk, we explore this peculiarity:

```{r Problem_1c}

as.numeric(var_vec_logic) * var_sample      ## Convert logical vector to numeric then multiplied with sample
as.factor(var_vec_logic) * var_sample       ## Convert logical vector to factor then multiplied with sample
as.numeric(as.factor(var_vec_logic)) * var_sample ## Convert logical vector to factor then numeric then multiplied                                                       with sample

```

With this exploration, we now can guesstimate that `factor()` stores the elements inside as characters categorized based on the "levels". Only when we convert these elements into numeric using `as.numeric` to get their numerical representation of the "levels" can we then operate on the factor as "numbers". We also notice that when we do this, `FALSE` is assigned 1 instead of 0 as in logical vectors, indicating that a factor's lowest "numeric" is 1. 

# Problem 2
## *Problem 2.a*

Create a data frame comprised of:

* x: a random sample of size 500 from a standard Normal distribution
* y: a random sample of size 500 from a standard Normal distribution
* A logical vector indicating whether x + y > 1
* A numeric vector created by coercing the above logical vector
* A factor vector created by coercing the above logical vector
* Write a short description of your vector using inline R code, including: * the size of the dataset (using nrow and ncol) * the mean, median, and standard deviation of x * the proportion of cases for which x + y > 1

```{r Problem_2a}

prob2_df <- tibble(
  x = rnorm(500),
  y = rnorm(500),
  xy_logic = x + y > 1,
  xy_num = as.numeric(xy_logic),
  xy_fac = as.factor(xy_logic)
)

```

Make a scatterplot of y vs x; color points using the logical variable (adding color = ... inside of aes in your ggplot code should help). Make a second and third scatterplot that color points using the numeric and factor variables, respectively, and comment on the color scales.

Export your first scatterplot to your project directory using ggsave