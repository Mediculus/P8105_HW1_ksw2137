---
title: "Homework 1 - P8105/Data Science I"
author: "Kevin S.W."
date: "9/12/2019"
output: github_document
---

```{r setup, include = FALSE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(echo = TRUE, eval = TRUE)
library(tidyverse)  ## loads tidyverse package; if not installed, use install(tidyverse) prior

```

# **Introduction**
This is an R-Markdown document for P8105 Homework 1. Tidyverse was loaded through a chunk with `include = FALSE, message = FALSE, warning = FALSE`. 

# Problem 1
## *Problem 1.a*
Data frame containing the variables as commented. 

```{r Problem_1a}

## Seed used for reproducibility.
set.seed(2)


## Creates a data-frame that is composed of vectors below
prob1_df <- tibble(
  df_sample = rnorm(8),                              ## Vector for random normal-distributed sample of size 8
  df_vec_logic = df_sample > 0,                         ## Logical vector that evaluates if elements in sample > 0
  df_vec_char = c("GitHub", "is", "super",           ## Character vector with 8 variables ("length == 8")
               "interesting", "and", "awesome", 
               "I", "can't even..."),
  df_vec_fac = factor(c("corn", "not corn", "corn",  ## Factor vector size 8 with 3 levels: "corn", 
              "maybe corn", "corn", "maybe corn",    ## "maybe corn", "not corn"
              "corn", "not corn"))
)


## pull() function pulls the vectors inside prob1_df and turns it into usable variables outside the df. This is 
## inconvenient at this point but makes downstream access to these vectors easier. 
## Using prob1_df$vector was considered bad syntax and was not utilized
sample <- pull(prob1_df, df_sample)
vec_logic <- pull(prob1_df, df_vec_logic)
vec_char <- pull(prob1_df, df_vec_char)
vec_fac <- pull(prob1_df, df_vec_fac)


## Takes the mean for each vectors
mean(sample)
mean(vec_logic)
mean(vec_char)
mean(vec_fac)

```

Taking the mean of sample seems to work as expected as it is a continuous variable. Logical vector surprisingly spits out a mean of `r mean(vec_logic)`. Looking into `prob1_df` seems to indicate that `FALSE` = 0 while `TRUE` = 1, which leads to `r length(which(vec_logic == TRUE))`/`r length(vec_logic)` TRUE, hence the calculated mean.

Mean for `vec_char` & `vec_fac` however, does not work. This is likely because characters are not read as "numbers" and therefore cannot be mathematically manipulated. 

## *Problem 1.b*
Applying the `as.numeric()` function to logical, character, and factor variables:

```{r Problem_1b, eval = FALSE}

as.numeric(vec_logic)
as.numeric(vec_char)
as.numeric(vec_fac)

```

The command outputs a numeric value that represents each element in the vectors. While the logical vector shows 0/1, character vector shows NA indicating that it doesn't have a numeric representation. Factor vectors however, has the value 1-3; this does not explain why factor vectors cannot output a mean. 

In the following code chunk, we explore this peculiarity:

```{r Problem_1c}

as.numeric(vec_logic) * sample      ## Convert logical vector to numeric then multiplied with sample
as.factor(vec_logic) * sample       ## Convert logical vector to factor then multiplied with sample
as.numeric(as.factor(vec_logic)) * sample ## Convert logical vector to factor then numeric then multiplied                                                       with sample

```

With this exploration, we now can guesstimate that `factor()` stores the elements inside as characters categorized based on the "levels". Only when we convert these elements into numeric using `as.numeric` to get their numerical representation of the "levels" can we then operate on the factor as "numbers". We also notice that when we do this, `FALSE` is assigned 1 instead of 0 as in logical vectors, which indicates that a factor's lowest "numeric" is 1. 

# Problem 2
## *Problem 2.a*
Data frame for problem 2. 

```{r Problem_2a}

prob2_df <- tibble(
  df_x = rnorm(500),                   ## Vector 1 of random normal distribution sample; size 500 
  df_y = rnorm(500),                   ## Vector 2 of random normal distribution sample; size 500 
  df_xy_logic = (df_x + df_y) > 1,     ## Logical vector that evaluates the argument x + y > 1
  df_xy_num = as.numeric(df_xy_logic), ## Vector that coerces xy_logic to be numeric vector
  df_xy_fac = as.factor(df_xy_logic)   ## Vector that coerces xy_logic to a factor vector
)


## pulls variable from prob2_df out of the df so it's usable outside
x <- pull(prob2_df, df_x)
xy_logic <- pull(prob2_df, df_xy_logic)
xy_num <- pull(prob2_df, df_xy_num)
xy_fac <- pull(prob2_df, df_xy_fac)

```

The `prob2_df` dataframe is a dataset of `r nrow(prob2_df) * ncol(prob2_df)` points in a grid of `r nrow(prob2_df)` rows X `r ncol(prob2_df)` columns. Columns contain values for `x`, `y`, `xy_logic`, `xy_num`, and `xy_fac`. 

The `x` column has a mean (sd) of `r mean(x)`, median of `r median(x)`, and standard deviation of `r sd(x)`.

The proportion of `TRUE` cases where `(x + y) > 1` is `r length(which(xy_logic == TRUE))`/`r length(xy_logic)`, which is `r (length(which(xy_logic == TRUE)) / length(xy_logic)) * 100`%.

## *Problem 2.b*
Make a scatterplot of y vs x; color points using the logical variable (adding color = ... inside of aes in your ggplot code should help). Make a second and third scatterplot that color points using the numeric and factor variables, respectively, and comment on the color scales.

```{r}

ggplot(data = prob2_df, aes(x = df_y, y = df_x, color = df_xy_logic)) + 
  geom_point() +
  labs(title = "Scatterplot for Y vs X", 
       subtitle = "Sample size 500; random nml distribution",
       x = "Y datapoints",
       y = "X datapoints",
       color = "(x + y) > 1") +
  theme(plot.title = element_text(hjust = 0.5, size = 18),
        plot.subtitle = element_text(hjust = 0.5, size = 8))

ggplot(data = prob2_df, aes(x = df_y, y = df_x, col = df_xy_num)) +
  geom_point()


ggplot(data = prob2_df, aes(x = df_y, y = df_x, col = df_xy_fac)) +
  geom_point()

```

Export your first scatterplot to your project directory using ggsave